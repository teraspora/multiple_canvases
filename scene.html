<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Playing with different scenes on multiple canvases">
    <meta name="author" content="John Lynch">
    <title>Multiple Canvas Scenes</title>
    <link rel="icon" href="data:,">
    <style>
        html, body, * {
            background-color: #000;
            margin: 0 auto;
            text-align: center;
            overflow: hidden;
        }
        #main {
            display: grid;
            width: 95vw;
            height: 95vh;
            gap: 30px;
            justify-content: space-around;
            align-content: space-around;
            border: 2px solid #333;
            margin: 1vw auto;
        }
        canvas {
            border: 6px ridge #ff9900;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="main">

    </div>
    <!-- <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script> -->
    <script>
        let DEBUG = false;
        const rand_int = n => Math.floor(n * Math.random());
        const rand_in_range = (m, n) => Math.floor((n - m) * Math.random() + m);

        class Atom {

        }

        class Scene {
            static instance_count = 0;
            constructor(canvas) {
                this.id = Scene.instance_count++;
                this.canvas = canvas;
                this.ctx = this.canvas.getContext("2d");
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.progress = 0;
                this.progress_delta = 0.02;
            }
            render() {
            }
            update(t) {
                this.progress += this.progress_delta;
            }
            test() {
                // Draw something simple and small, just to verify canvas drawability!
                this.ctx.fillStyle = `hsl(${Math.random() * 360} 100% 50%)`;
                this.ctx.fillRect(8, 8, 16, 16);
            }
        }


        class CurveScene extends Scene {
            static instance_count = 0;
            
            // Curves
            static curves = {
                rhodonea: (k, amp, t) => [
                    amp * Math.cos(k * t + t) * Math.cos(t),
                    amp * Math.cos(k * t + t) * Math.sin(t),
                ],
                ellipse: (a, b, t) => [
                    a * Math.cos(t),
                    b * Math.sin(t)
                ],
                trig_grid: (p, q, t) => {
                    const amplitude = 200;
                    return [            
                        amplitude * Math.sin(p * Math.PI * t / 10),
                        amplitude * Math.cos(q * Math.PI * t / 10)
                    ]
                },
                hcrr: (R, r, amp, t) => {
                    const s = R - r;
                    return [
                        amp * (s * Math.cos(t) + r * Math.cos(s / r * t)),
                        amp * (s * Math.sin(t) - r * Math.sin(s / r * t))
                    ]
                },
                hypocycloid: (a, b, amp, t) => {
                    const r = a - b;
                    const p = r / b;
                    return [
                    amp * r * Math.cos(t) + b * Math.cos(p * t),
                    amp * r * Math.sin(t) - b * Math.sin(p * t)
                    ]
                },
                spiral: (r, density, t) => {
                    const r_ = r * (density * Math.PI - t) / (density * Math.PI);
                    return [
                        r_ * Math.cos(-t),
                        r_ * Math.sin(-t)
                    ];
                }
            };
            // =========================================

            constructor(canvas, curve, params, thickness) {
                super(canvas);
                this.ctx.lineWidth = thickness;
                this.curve_name = curve;
                this.curve = CurveScene.curves[this.curve_name];
                this.params = params;
                this.x_previous = 0;
                this.y_previous = 0;
                this.hue_initial = Math.random() * 360;
            }

            render() {
                // Called by user subsequent to instantiation.   Kicks off the animation.
                const [x, y] = this.curve(...this.params, 0);
                this.x_previous = x + this.width / 2;
                this.y_previous = y + this.height / 2;
                this.ctx.font = "20px monospace"
                this.ctx.fillStyle = '#4df';
                this.ctx.fillText(this.curve_name, this.width - 180, this.height - 50);
                this.ctx.fillText(`(${this.params})`, this.width - 18 * this.params.toString().length - 20, this.height - 20);
                requestAnimationFrame(this.update.bind(this));
            }

            update() {
                // Called for every repaint, by requestAnimationFrame()
                super.update();
                const [x, y] = this.curve(...this.params, this.progress);
                const [x_next, y_next] = [x + this.width / 2, y + this.height / 2];
                this.ctx.strokeStyle = `hsl(${this.hue_initial + this.progress * 100} 100% 50%)`;
                this.ctx.moveTo(this.x_previous, this.y_previous);
                this.ctx.lineTo(x_next, y_next);
                [this.x_previous, this.y_previous] = [x_next, y_next];
                this.ctx.stroke();
                this.ctx.beginPath();            
                requestAnimationFrame(this.update.bind(this));
            }
        }

        // Top-level code
        let canvas_count = 9; // must be a perfect square!
        const scenes = [];
        const cols = Math.sqrt(canvas_count);
        const main = document.getElementById('main');
        main.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        const {width: main_width, height: main_height} = main.getBoundingClientRect();
        
        // Create an array of canvases and add each one to the DOM
        const canvases = Array(canvas_count).fill(0).map((_, i) => {
            const c = document.createElement('canvas');
            c.id = `canvas-${i}`;
            c.width = main_width / cols - 50;
            c.height = main_height / cols - 50;
            main.appendChild(c);
            return c;
        });

        // For each canvas, create a new Scene, and push the new Scene to an array of scenes.
        let curve, params;
        canvases.forEach(canvas => {
            let amp, k, a, b, r, density;
            const i = rand_int(6);
            switch(i) {
                case 0:
                    curve = 'hcrr';
                    params = [2 * Math.PI, 2, rand_in_range(32, 64)];
                    break;
                case 1:
                    r = rand_in_range(128, 192);
                    density = rand_in_range(12, 64);
                    curve = 'spiral';
                    params = [r, density];
                    break;
                case 2:
                    curve = 'trig_grid';
                    params = [rand_in_range(3, 16), rand_in_range(3, 16)];
                    break;
                case 3:
                    k = rand_in_range(1, 13) / rand_in_range(1, 23);
                    amp = rand_in_range(150, 200);
                    curve = 'rhodonea';
                    params = [k, amp];
                    break;
                case 4:
                    a = rand_in_range(1, 6);
                    b = rand_in_range(1, 6);
                    amp = rand_in_range(20, canvas.width / 6);
                    curve = 'hypocycloid';
                    params = [a, b, amp] ;
                    break;
                default:
                    a = rand_in_range(30, 120);
                    b = rand_in_range(30, 120);
                    curve = 'ellipse';
                    params = [a, b];
                }

            const s = new CurveScene(canvas, curve, params, rand_in_range(2, 5));
            scenes.push(s);
            if (DEBUG) {
                // test() method should draw something simple and small, just to verify canvas drawability!
                s.test();
            }
        });

        window.addEventListener('keyup', event => {
            if (!event.ctrlKey && !event.altKey) {
                const char = event.key.toUpperCase();
                switch(char) {
                    case '4':
                    case '9':
                        canvas_count = Number(char);
                        location.reload();
                        break;
                    default:
                }
            }
        });

        // Render scenes in a separate loop, as we may want this to be separate from scene creation in the future.
        for (scene of scenes) {
            scene.render();
        }

    </script>

</body>
</html>
