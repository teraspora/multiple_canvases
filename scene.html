<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Playing with different scenes on multiple canvases">
    <meta name="author" content="John Lynch">
    <title>Multiple Canvas Scenes</title>
    <link rel="icon" href="data:,">
    <style>
        html, body, * {
            background-color: #000;
            margin: 0 auto;
            text-align: center;
            overflow: hidden;
        }
        #main {
            display: grid;
            width: 95vw;
            height: 95vh;
            gap: 30px;
            justify-content: space-around;
            align-content: space-around;
            border: 2px solid #333;
            margin: 1vw auto;
        }
        canvas {
            border: 6px ridge #ff9900;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="main">

    </div>
    <!-- <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script> -->
    <script>
        let DEBUG = true;
        const rand_int = n => Math.floor(n * Math.random());
        const rand_in_range = (m, n) => Math.floor((n - m) * Math.random() + m);

        class Atom {

        }

        class Scene {
            static instance_count = 0;
            
            // Curves
            static curves = {
                rhodonea: (k, amp, t) => [
                    amp * Math.cos(k * t + t) * Math.cos(t),
                    amp * Math.cos(k * t + t) * Math.sin(t),
                ],
                ellipse: (a, b, t) => [
                    a * Math.cos(t),
                    b * Math.sin(t)
                ]
            };
            // =========================================

            constructor(canvas, curve, params, thickness) {
                this.id = Scene.instance_count++;
                this.canvas = canvas;
                this.ctx = this.canvas.getContext("2d");
                this.ctx.lineWidth = thickness;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.curve = Scene.curves[curve];
                this.params = params;
                this.x_previous = 0;
                this.y_previous = 0;
            }

            render() {
                // Called by user subsequent to instantiation.   Kicks off the animation.
                console.log('In render():\n', this);
                const [x, y] = this.curve(...this.params, 0);
                this.x_previous = x + this.width / 2;
                this.y_previous = y + this.height / 2;
                requestAnimationFrame(this.update.bind(this));
            }

            update(t) {
                // Called for every repaint, by requestAnimationFrame()
                const [x, y] = this.curve(...this.params, t / 1000);
                const [x_next, y_next] = [x + this.width / 2, y + this.height / 2];
                this.ctx.strokeStyle = `hsl(${rand_int(360) - t / 32} 100% 50%)`;
                this.ctx.moveTo(this.x_previous, this.y_previous);
                this.ctx.lineTo(x_next, y_next);
                [this.x_previous, this.y_previous] = [x_next, y_next];
                this.ctx.stroke();
                this.ctx.beginPath();            
                requestAnimationFrame(this.update.bind(this));
            }

            test() {
                // Draw something simple and small, just to verify canvas drawability!
                this.ctx.fillStyle = `hsl(${Math.random() * 360} 100% 50%)`;
                this.ctx.fillRect(8, 8, 16, 16);
            }
        }

        // Top-level code
        const scenes = [];
        const CANVAS_COUNT = 9; // must be a perfect square!
        const cols = Math.sqrt(CANVAS_COUNT);
        const main = document.getElementById('main');
        main.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        const {width: main_width, height: main_height} = main.getBoundingClientRect();
        
        // Create an array of canvases and add each one to the DOM
        const canvases = Array(CANVAS_COUNT).fill(0).map((_, i) => {
            const c = document.createElement('canvas');
            c.id = `canvas-${i}`;
            c.width = main_width / cols - 50;
            c.height = main_height / cols - 50;
            main.appendChild(c);
            return c;
        });

        // For each canvas, create a new Scene, and push the new Scene to an array of scenes.
        var even = false;
        let curve, params;
        canvases.forEach(canvas => {
            if (even = !even) {
                const k = rand_in_range(1, 13) / rand_in_range(1, 23);
                const amp = rand_in_range(60, 120);
                curve = 'rhodonea';
                params = [k, amp];
            }
            else {
                const a = rand_in_range(3, 120);
                const b = rand_in_range(3, 120);
                curve = 'ellipse';
                params = [a, b];
            }

            const s = new Scene(canvas, curve, params, rand_in_range(2, 5));
            scenes.push(s);
            if (DEBUG) {
                // test() method should draw something simple and small, just to verify canvas drawability!
                s.test();
            }
        });

        // Render scenes in a separate loop, as we may want this to be separate from scene creation in the future.
        for (scene of scenes) {
            scene.render();
        }

            // NEXT TO DO: 
            // Pass animation code to scene constructor

    </script>

</body>
</html>
