<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Playing with different scenes on multiple canvases">
    <meta name="author" content="John Lynch">
    <title>Multiple Canvas Scenes</title>
    <link rel="icon" href="data:,">
    <style>
        html, body, * {
            background-color: #000;
            margin: 0 auto;
            text-align: center;
            overflow: hidden;
        }
        #main {
            display: grid;
            width: 95vw;
            height: 95vh;
            gap: 30px;
            justify-content: space-around;
            align-content: space-around;
            border: 2px solid #333;
            margin: 1vw auto;
        }
        canvas {
            border: 6px ridge #ff9900;
        }
    </style>
</head>
<body>
    <div id="main">

    </div>
    <!-- <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script> -->
    <script>
        let DEBUG = true;
        class Scene {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = this.canvas.getContext("2d");
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }
            test() {
                this.ctx.fillStyle = `hsl(${Math.random() * 360} 100% 50%)`;
                this.ctx.fillRect(16, 16, 64, 64);
            }
        }
        const scenes = [];
        const CANVAS_COUNT = 9; // must be a perfect square!
        const cols = Math.sqrt(CANVAS_COUNT);
        const main = document.getElementById('main');
        main.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        const {width: main_width, height: main_height} = main.getBoundingClientRect();
        const canvases = Array(CANVAS_COUNT).fill(0).map((_, i) => {
            const c = document.createElement('canvas');
            c.id = `canvas-${i}`;
            c.width = main_width / cols - 50;
            c.height = main_height / cols - 50;
            main.appendChild(c);
            return c;
        });
        canvases.forEach(c => {
            const s = new Scene(c);
            scenes.push(s);
            if (DEBUG) {
                s.test();
            }
        });

        // Scene 0

        for (scene of scenes) {
            render_scene(scene);
        }

        function render_scene(scene) {
            const k = 8 / 7;
            const amp = 60;
            const rhodonea = (k, amp, t) => [
                amp * Math.cos(k * t + t) * Math.cos(t),
                amp * Math.cos(k * t + t) * Math.sin(t),
            ];
            const [x, y] = rhodonea(k, amp, 0);
            let x_old = x + scene.width / 2;
            let y_old = y + scene.height / 2;

            function update(t) {
                const [x, y] = rhodonea(k, amp, t / 1000);
                const [x_new, y_new] = [x + scene.width / 2, y + scene.height / 2];
                scene.ctx.strokeStyle = `hsl(${360 - t / 32} 100% 50%)`;
                scene.ctx.moveTo(x_old, y_old);
                scene.ctx.lineTo(x_new, y_new);
                // ctx.strokeRect(x_old, y_old, 1, 1);
                [x_old, y_old] = [x_new, y_new];
                scene.ctx.stroke();
                scene.ctx.beginPath();            
                requestAnimationFrame(update);
            }
            requestAnimationFrame(update);            
        }
    </script>

</body>
</html>
